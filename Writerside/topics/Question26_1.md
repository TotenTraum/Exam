# Вопрос 26
## Принцип устойчивости абстракций
<tip>
Устойчивость компонента пропорциональна его абстрактности.
</tip>
Гласит о том, что абстракции в программной системе должны быть стабильными, то есть изменения в низкоуровневых компонентах не должны приводить к неожиданным изменениям в высокоуровневых компонентах.

Согласно принципу устойчивых абстракций, высокоуровневые модули или классы должны быть более стабильными и менее зависимыми от изменений, в то время как низкоуровневые модули должны быть менее стабильными и более зависимыми. Это обеспечивает гибкость и возможность изменения низкоуровневых компонентов без влияния на высокоуровневую логику.

## Пример
### Разделение интерфейсов:

* Создание стабильного интерфейса, который определяет базовые операции или методы, не подверженных частым изменениям.
* Разделение этого интерфейса на более конкретные интерфейсы, которые могут содержать дополнительные методы или операции, но менее стабильные и более подверженные изменениям.

Например, веб-приложение для управления задачами может иметь интерфейс TaskManager, который определяет основные операции, такие как создание, чтение, обновление и удаление задач. Этот интерфейс будет стабильным и мало подверженным изменениям. Затем можно создать интерфейс ExtendedTaskManager, который наследует TaskManager и добавляет дополнительные методы, такие как фильтрация или сортировка задач. Этот интерфейс будет менее стабильным и более подверженным изменениям.

### Использование абстрактных классов или интерфейсов в качестве промежуточных слоев:

* Создание стабильных абстрактных классов или интерфейсов, которые определяют основные функциональные возможности и не подвержены изменениям.
* Разделение этих абстрактных классов или интерфейсов на более конкретные классы или интерфейсы, которые могут содержать дополнительную функциональность или логику, но менее стабильны и подвержены изменениям.

Например, в приложении для обработки платежей можно иметь абстрактный класс PaymentProcessor, который определяет основные методы для обработки платежей. Этот класс будет стабильным и мало подверженным изменениям. Затем можно создать конкретные классы, такие как CreditCardPaymentProcessor или PayPalPaymentProcessor, которые наследуют PaymentProcessor и реализуют специфичную логику для обработки платежей через конкретные платежные системы. Эти классы будут менее стабильными и более подверженными изменениям.